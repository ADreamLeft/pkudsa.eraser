#### To do list：

- 生成盘面： 用`np.array`；
- 初始化：改成`np.shuffle`，提前生成100个合格的，上传到`Github`；
- 要求同学们返回一个class，class里面要有一个`class.move`方法：
  - 接收当前回合大棋盘`np.array`（二维列表），空的就是NA；**以及**所有可以形成消除的操作（**形式待定**）；
  - 返回一个`[[x1, y1], [x2, y2]]`，必须是合法的两个坐标交换（必须合法）。
- 进行对局`self.update`，移动->**消除->计分**（需要考虑**多种情况**）->重力下落；
  - 尽量全部用`numpy`方法实现；
  - 消除`self.eliminate`：`BFS`搜，强连通相邻搜出来所有cluster，顺便维护列index的变化；
  - 计分`self.count_score`：直接在上一步加；循环...；
  - 重力下落`self.gravity`：已经维护好了（乐）；
  - 最后返回棋盘：把更新好的index的array拼起来。（***自己衡量！***）
- 异常处理：
  - 非法格式输入，不相邻的点，超出范围的点；
  - 超时；
  - 最大回合数或者没棋子了，游戏结束。等等！
- 双方对战胜负处理：
  - 先手后手轮流打同一个棋局（需要**内测**保证尽量平衡）；
  - 算总分，平了就加赛，不平为止。
- 复盘数据&可视化：每一步移动之后调用函数`self.record`，返回格式要求：
  - 回合操作前的棋盘；
  - 每次棋盘布局变化，发生变化的格子的前后状态；
  - 然后把它生成为`json`，里面先手后手计分等等；
- 服务器，对战平台：（乐）



类&函数的格式：

- 